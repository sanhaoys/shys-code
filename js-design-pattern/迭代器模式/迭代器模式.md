# 迭代器模式

> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中每个元素

## 一个简单的迭代器

```javascript
var each = function (arrLike, cb) {
  // 使用l保证arrLike的length在迭代过程中被修改之后行为不受影响
  for (var i = 0, l = arrLike.length; i < l; i++) {
    cb.call(arrLike[i], arrLike[i], i)
  }
}

each([1, 2, 3], function (val, index) {
  console.log('arr[' + index + '] = ' + val)
})
```

## 内部迭代器和外部迭代器

迭代器可以分为内部迭代器和外部迭代器，分别有不同的使用场景

### 内部迭代器

上面迭代器的例子就是一个内部迭代器，外界不需要关心迭代器内部的实现，跟迭代器的交互也仅有一次初始调用，但这也是内部迭代器的缺点，迭代规则已经被提前规定，each 函数无法同时迭代两个数组了，如果有需求比较两个数组，那么只能从 cb 中做处理

```javascript
// 同时比较两个数组
var compare = function (arr1, arr2) {
  if (arr1.length !== arr2.length) {
    throw new Error('Not equal')
  }
  each(arr1, function (val, i) {
    if (val !== arr2[i]) {
      throw new Error('Not equal')
    }
  })
  console.log('相等')
}

compare([1, 2, 3], [1, 2, 3])
```

能完成这个逻辑，是因为 js 中可以将函数当参数传递，显然这并不优雅

### 外部迭代器

外部迭代器必须显式的请求下一个元素
