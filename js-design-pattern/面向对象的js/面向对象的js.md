# 设计模式

模式是对已有解决方法的提炼总结

**面向接口编程**是设计模式中最重要的思想，js 本身就是动态类型语言，js 的多态是天生的。

## 多态

多态是面向对象编程语言最重要的技术，多态保证了不需要关心如何实现，而是关注如何调用。多态就是通过把过程化的条件分支语句转化为对象的多态性，从而消除条件分支语句。

```javascript
var duck = {
  sound: function () {
    console.log('ga ga ga')
  },
}

var chicken = {
  sound: function () {
    console.log('go go go')
  },
}

function animalSound(animal) {
  // 不需要关心是什么动物，只要这个动物可以发出声音就可以
  if (animal && typeof animal.sound === 'function') {
    animal.sound()
  }
}

animalSound(duck) // ga ga ga
animalSound(chicken) // go go go
```

## 封装

封装的目的是将信息隐藏

### 封装数据

对于其他语言，提供了类似`private`、`public`、`protected`等修饰符来提供不同的访问权限。js 中并没有访问权限的概念，但是可以通过闭包来进行数据封装

```javascript
var _data = (function () {
  var name = '_data'

  return {
    getName() {
      return name
    },
  }
})()

console.log(_data.getName()) // _data
console.log(_data.name) // undefined
```

### 封装实现

封装实现细节让对象内部的变化与其他对象而言都是透明的，对象为自己的行为负责。其他对象不需要关心内部实现，封装使得对象之间的耦合变得松散，对象之间只通过暴露的 api 接口进行通信。当修改一个对象时，可以随意修改他的内部实现，只要对外的接口没有变化，就不会影响程序的其他功能

### 封装类型

封装类型是静态语言中主要的一种封装方式，在`java`中是通过抽象类和接口来实现的。把对象的真正类型隐藏在抽象类/接口之后。只关心对象的行为，在 js 中，并没有抽象类和接口的支持(TS 支持)

### 封装变化

从设计模式角度出发，封装在更重要的层面体现在**封装变化**

> 考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。
> 它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情况
> 下进行改变。这里的关键在于封装发生变化的概念，这是许多设计模式的主题。

## 原型模式和基于原型继承的 js 对象系统

### 原型模式

要创建一个对象，需要找到这个对象的类型并通过类来创建这个对象，而原型模式采取了另一种方式:`clone`，不再关心对象的具体类型，而是找到一个对象，然后通过克隆创建一个一模一样的对象

原型模式的关键是语言本身是否提供了 clone 方法，ES5 有了`Object.create`来克隆对象

js 的对象系统就是通过原型模式来搭建的，叫做原型编程范式更合适

### 原型编程范式

js 可以理解为原型编程范式，符合以下几个特点

- 所有的数据都是对象
- 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并 clone 它
- 对象会记住它的原型
- 如果对象无法响应某个请求，就会将请求委托给它自己的原型

js 是如何在以上特点中构建对象系统的呢

1. **所有的数据都是对象**
   js 在设计时参考 java 引入了基础类型和引用类型，按照该特点，除了 undefined 之外应该全部都是对象，所以基础类型也有上层的包装类型来让其成为引用类型。  
   Object.prototype 就是 js 的根对象，每个 js 对象都是从其 clone 而来的。这个对象就是他们的原型链顶层
2. **要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并 clone 它**
   在 js 中，不需要关心 clone 的细节，因为引擎内部已经实现了。  
   只需要显式的调用`var obj = {}`或其他创建对象的方法，引擎内部就会从 Object.prototype clone 一个对象出来。  
   js 中的函数既可以作为普通函数使用，也可以作为构造器使用，当使用 new 运算符来调用函数是，此时的函数就是一个构造器。(此过程可以参考 js deep new 的模拟实现)
3. **对象会记住它的原型**
   js 给实例提供一个`__proto__`隐藏属性来指向构造函数原型（其实这个属性也是原型提供给实例的 XD）
4. **如果对象无法响应某个请求，就会将请求委托给它自己的原型**
   参考 js deep 的原型链

## 高阶函数

高阶函数是值至少满足以下两个条件之一的函数。

- 函数可以作为参数被传递
- 函数可以作为返回值输出
